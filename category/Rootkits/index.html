<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>ho.ax - </title>
    <link rel="stylesheet" type="text/css" href="/css/reset.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/css/grid.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/css/style.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/css/highlight.css" media="screen">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://ho.ax/feed.xml">
  </head>
  <body>
      <div id="container">
        <div id="header">
          <div class="container_12">
            <div class="grid_6">
              <h1><a href="/">ho/ax.</a></h1>
            </div>
            <div class="grid_6">
              <div class="media">
                <div style="float: left"><a class="twitter" href="http://twitter.com/snare"></a></div>
                <div style="float: left"><a class="rss" href="/feed.xml"></a></div>
              </div>
            </div>
          </div>
        </div>
        <div id="splitbar">&nbsp;</div>
        <div id="main">
          <div class="container_12">
            <div class="grid_9">
              <div id="content">
                
  <h1><a href="/posts/2012/03/rip-relative-addressing-and-kernel-payloads/">RIP-Relative Addressing and Kernel Payloads</a></h1>
<p class="metadata">
	Posted by snare on 9 March 2012. Tags: <a class="tag" href="/tag/mac os x/" rel="tag">mac os x</a>, <a class="tag" href="/tag/x86-64/" rel="tag">x86-64</a>, <a class="tag" href="/tag/clang/" rel="tag">clang</a>
</p>

<p>The x86-64 architecture introduced a new way to generate Position-Independent Code (PIC) – RIP-relative addressing. RIP-relative addressing works by referencing data and functions by an address relative to the current instruction pointer, so that “fixups” are not needed for local functions when relocating a piece of code to a base address other than that for which it was linked. I won’t go into too much detail about load-time relocation or PIC on x86, but if you’re interested in the details I recommend reading Eli Bendersky’s excellent write ups on how <a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/">load-time relocation</a>, <a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">x86 PIC</a> and <a href="http://eli.thegreenplace.net/2011/11/11/position-independent-code-pic-in-shared-libraries-on-x64/">x86_64 PIC</a> work on Linux/ELF, as the concepts are fairly similar to how it works on OS X/Mach-O.</p>

<p>RIP-relative addressing became a bit of a problem for me when I was generating kernel payloads that I wanted to be able to relocate to different areas of memory. I’ll explain by way of example.</p>

<p>Consider the following dummy kernel extension:</p>

<pre><code class="language-c"><span class="cp">#include &lt;mach/mach_types.h&gt;</span>
<span class="cp">#include &lt;sys/systm.h&gt;</span>

<span class="n">kern_return_t</span> <span class="n">TestPayload_start</span><span class="p">(</span><span class="n">kmod_info_t</span> <span class="o">*</span> <span class="n">ki</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="n">kern_return_t</span> <span class="n">TestPayload_stop</span><span class="p">(</span><span class="n">kmod_info_t</span> <span class="o">*</span><span class="n">ki</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>

<span class="n">kern_return_t</span> <span class="nf">TestPayload_start</span><span class="p">(</span><span class="n">kmod_info_t</span> <span class="o">*</span> <span class="n">ki</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sup</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">kern_return_t</span> <span class="nf">TestPayload_stop</span><span class="p">(</span><span class="n">kmod_info_t</span> <span class="o">*</span><span class="n">ki</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>This is only slightly modified from the default code that is generated when we create a new Kernel Extension project in Xcode – I just added the <code>printf()</code> and relevant <code>#include</code>. If we compile this in the normal way with Xcode, and disassemble the executable:</p>

<pre><code>$ otool -tv TestPayload.kext/Contents/MacOS/TestPayload
_TestPayload_start:
0000000000000f20	pushq	%rbp
0000000000000f21	movq	%rsp,%rbp
0000000000000f24	subq	$0x20,%rsp
0000000000000f28	movq	%rdi,0xf8(%rbp)
0000000000000f2c	movq	%rsi,0xf0(%rbp)
0000000000000f30	xorb	%al,%al
0000000000000f32	leaq	0x000000b3(%rip),%rcx
0000000000000f39	movq	%rcx,%rdi
0000000000000f3c	callq	0x00000f41
0000000000000f41	movl	$0x00000000,0xe8(%rbp)
0000000000000f48	movl	0xe8(%rbp),%eax
0000000000000f4b	movl	%eax,0xec(%rbp)
0000000000000f4e	movl	0xec(%rbp),%eax
0000000000000f51	addq	$0x20,%rsp
0000000000000f55	popq	%rbp
0000000000000f56	ret
0000000000000f57	nopw	0x00000000(%rax,%rax)
_TestPayload_stop:
0000000000000f60	pushq	%rbp
0000000000000f61	movq	%rsp,%rbp
0000000000000f64	subq	$0x18,%rsp
0000000000000f68	movq	%rdi,0xf8(%rbp)
0000000000000f6c	movq	%rsi,0xf0(%rbp)
0000000000000f70	movl	$0x00000000,0xe8(%rbp)
0000000000000f77	movl	0xe8(%rbp),%eax
0000000000000f7a	movl	%eax,0xec(%rbp)
0000000000000f7d	movl	0xec(%rbp),%eax
0000000000000f80	addq	$0x18,%rsp
0000000000000f84	popq	%rbp
0000000000000f85	ret
&lt;snip&gt;
</code></pre>

<p>Note the <code>callq 0x00000f41</code> at <code>0xf3c</code> there – that’s the call to <code>printf()</code>. If we dump the section without disassembling:</p>

<pre><code>$ otool -t TestPayload.kext/Contents/MacOS/TestPayload 
TestPayload:
(__TEXT,__text) section
0000000000000f20 55 48 89 e5 48 83 ec 20 48 89 7d f8 48 89 75 f0 
0000000000000f30 30 c0 48 8d 0d b3 00 00 00 48 89 cf e8 00 00 00 
0000000000000f40 00 c7 45 e8 00 00 00 00 8b 45 e8 89 45 ec 8b 45 
0000000000000f50 ec 48 83 c4 20 5d c3 66 0f 1f 84 00 00 00 00 00 
0000000000000f60 55 48 89 e5 48 83 ec 18 48 89 7d f8 48 89 75 f0 
0000000000000f70 c7 45 e8 00 00 00 00 8b 45 e8 89 45 ec 8b 45 ec 
0000000000000f80 48 83 c4 18 5d c3 55 48 89 e5 48 8d 05 37 01 00 
0000000000000f90 00 48 8b 00 48 85 c0 75 04 31 c0 5d c3 5d ff e0 
0000000000000fa0 55 48 89 e5 48 8d 05 55 00 00 00 48 83 c0 10 5d 
0000000000000fb0 c3 55 48 89 e5 48 8d 05 44 00 00 00 48 83 c0 50 
0000000000000fc0 5d c3 55 48 89 e5 48 8d 05 33 00 00 00 8b 40 0c 
0000000000000fd0 5d c3 55 48 89 e5 48 8d 05 f3 00 00 00 48 8b 00 
0000000000000fe0 48 85 c0 75 04 31 c0 5d c3 5d ff e0 
</code></pre>

<p>We can see at <code>0xf3c</code> an instruction that looks like <code>e8 00 00 00 00</code> – this is a RIP-relative <code>call</code> instruction opcode (<code>e8</code>), followed by the 32-bit displacement (<code>00 00 00 00</code>). This is supposed to be the <code>printf()</code> call? Well, yeah. The compiler doesn’t know the address of the <code>printf()</code> function in the kernel at compile time, so it puts in <code>0x0</code> as a placeholder which will be updated when the executable is loaded and linked by KXLD. So how does KXLD know that this instruction needs updating? Relocation entries. Have a look at the relocation entries for the executable:</p>

<pre><code>$ otool -r TestPayload.kext/Contents/MacOS/TestPayload 
TestPayload.kext/Contents/MacOS/TestPayload:
External relocation information 1 entries
address  pcrel length extern type    scattered symbolnum/value
00000f3d 1     2      1      2       0         31
&lt;snip&gt;
</code></pre>

<p>We’re only concerned about the external relocations in this instance – we can see there is only one of these, and its address (offset within the executable file) is <code>0xf3d</code>. This happens to be one byte after the <code>e8</code> (<code>call</code>) instruction – the location of the displacement value for the RIP-relative call. It’s also worth noting there that the <code>pcrel</code> field is 1 – indicating that this is, in fact, a RIP-relative instruction. The other fields give the linker more information about how the relocation entry should be handled. You can find more info about these fields in the <a href="https://developer.apple.com/library/mac/#documentation/developertools/conceptual/MachORuntime/Reference/reference.html%23//apple_ref/c/tag/relocation_info">ABI documentation</a>.</p>

<p>So, back to my kernel payloads – I wanted to be able to move the payload around in memory without having to update the relocation entries each time, as that would require keeping the code to perform this updating within the payload. There are a few compiler options for generating slightly-more-position-independent code, but the OS X version of GCC doesn’t seem to support them. Fortunately, Clang does. If we compile with the <code>-mcmodel=large</code> option (by adding it to the “Other C Flags” field in the Xcode build settings), and disassemble the executable:</p>

<pre><code>$ otool -tv TestPayload.kext/Contents/MacOS/TestPayload 
TestPayload.kext/Contents/MacOS/TestPayload:
(__TEXT,__text) section
_TestPayload_start:
0000000000000f30	pushq	%rbp
0000000000000f31	movq	%rsp,%rbp
0000000000000f34	subq	$0x20,%rsp
0000000000000f38	movq	%rdi,0xf8(%rbp)
0000000000000f3c	movq	%rsi,0xf0(%rbp)
0000000000000f40	xorb	%al,%al
0000000000000f42	movq	$0x0000000000000ff1,%rdi
0000000000000f4c	movq	$0x0000000000000000,%rsi
0000000000000f56	call	*%rsi
0000000000000f58	movl	$0x00000000,%ecx
0000000000000f5d	movl	%eax,0xec(%rbp)
0000000000000f60	movl	%ecx,%eax
0000000000000f62	addq	$0x20,%rsp
0000000000000f66	popq	%rbp
0000000000000f67	ret
0000000000000f68	nopl	0x00000000(%rax,%rax)
_TestPayload_stop:
0000000000000f70	pushq	%rbp
0000000000000f71	movq	%rsp,%rbp
0000000000000f74	subq	$0x10,%rsp
0000000000000f78	movl	$0x00000000,%eax
0000000000000f7d	movq	%rdi,0xf8(%rbp)
0000000000000f81	movq	%rsi,0xf0(%rbp)
0000000000000f85	addq	$0x10,%rsp
0000000000000f89	popq	%rbp
0000000000000f8a	ret
&lt;snip&gt;
</code></pre>

<p>Now we have a <code>call</code> with an absolute 64-bit address by moving the address of the function into a register and <code>call</code>ing the value of that register. If we have a look at the relocation entries now:</p>

<pre><code>$ otool -r TestPayload.kext/Contents/MacOS/TestPayload 
TestPayload.kext/Contents/MacOS/TestPayload:
External relocation information 1 entries
address  pcrel length extern type    scattered symbolnum/value
00000f4e 0     3      1      0       0         31
&lt;snip&gt;
</code></pre>

<p>Notice <code>pcrel</code> is now 0, as it’s an absolute 64-bit address that we’re updating instead of a 32-bit displacement from RIP. This means that we can look up the address of the symbol (e.g. <code>printf()</code>) once when we initially load the payload, and update the relocation entry (or entries) to point to that address. Unfortunately this inflates the size of the code a bit, as all function calls are treated this way, which kind of defeats the purpose of trimming the relocation code – once we reach a certain payload size anyway. Oh well, it’s still a bit easier to handle. Next stop might be to write an LLVM pass to convert only external calls to absolute calls.</p>

<p>I’m not sure how useful this will be to others, but I thought it was interesting!</p>


  
	<hr/>
  

  <h1><a href="/posts/2012/02/resolving-kernel-symbols/">Resolving kernel symbols</a></h1>
<p class="metadata">
	Posted by snare on 25 February 2012. Tags: <a class="tag" href="/tag/mac os x/" rel="tag">mac os x</a>, <a class="tag" href="/tag/kernel/" rel="tag">kernel</a>, <a class="tag" href="/tag/kexts/" rel="tag">kexts</a>, <a class="tag" href="/tag/rootkits/" rel="tag">rootkits</a>, <a class="tag" href="/tag/mach-o/" rel="tag">mach-o</a>
</p>

<p>KXLD doesn’t like us much. He has KPIs to meet and doesn’t have time to help out shifty rootkit developers. KPIs are Kernel Programming Interfaces - lists of symbols in the kernel that KXLD (the kernel extension linker) will allow kexts to be linked against. The KPIs on which your kext depends are specified in the <code>Info.plist</code> file like this:</p>

<pre><code class="language-xml"><span class="nt">&lt;key&gt;</span>OSBundleLibraries<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;dict&gt;</span>
	<span class="nt">&lt;key&gt;</span>com.apple.kpi.bsd<span class="nt">&lt;/key&gt;</span>
	<span class="nt">&lt;string&gt;</span>11.0<span class="nt">&lt;/string&gt;</span>
	<span class="nt">&lt;key&gt;</span>com.apple.kpi.libkern<span class="nt">&lt;/key&gt;</span>
	<span class="nt">&lt;string&gt;</span>11.0<span class="nt">&lt;/string&gt;</span>
	<span class="nt">&lt;key&gt;</span>com.apple.kpi.mach<span class="nt">&lt;/key&gt;</span>
	<span class="nt">&lt;string&gt;</span>11.0<span class="nt">&lt;/string&gt;</span>
	<span class="nt">&lt;key&gt;</span>com.apple.kpi.unsupported<span class="nt">&lt;/key&gt;</span>
	<span class="nt">&lt;string&gt;</span>11.0<span class="nt">&lt;/string&gt;</span>
	<span class="nt">&lt;key&gt;</span>com.apple.kpi.iokit<span class="nt">&lt;/key&gt;</span>
	<span class="nt">&lt;string&gt;</span>11.0<span class="nt">&lt;/string&gt;</span>
	<span class="nt">&lt;key&gt;</span>com.apple.kpi.dsep<span class="nt">&lt;/key&gt;</span>
	<span class="nt">&lt;string&gt;</span>11.0<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/dict&gt;</span></code></pre>

<p>Those bundle identifiers correspond to the <code>CFBundleIdentifier</code> key specified in the <code>Info.plist</code> files for “plug-ins” to the <code>System.kext</code> kernel extension. Each KPI has its own plug-in kext - for example, the <code>com.apple.kpi.bsd</code> symbol table lives in <code>BSDKernel.kext</code>. These aren’t exactly complete kexts, they’re just Mach-O binaries with symbol tables full of undefined symbols (they really reside within the kernel image), which you can see if we dump the load commands:</p>

<pre><code>$ otool -l /System/Library/Extensions/System.kext/PlugIns/BSDKernel.kext/BSDKernel 
/System/Library/Extensions/System.kext/PlugIns/BSDKernel.kext/BSDKernel:
Load command 0
     cmd LC_SYMTAB
 cmdsize 24
  symoff 80
   nsyms 830
  stroff 13360
 strsize 13324
Load command 1
     cmd LC_UUID
 cmdsize 24
    uuid B171D4B0-AC45-47FC-8098-5B2F89B474E6
</code></pre>

<p>That’s it - just the <code>LC_SYMTAB</code> (symbol table). So, how many symbols are there in the kernel image?</p>

<pre><code>$ nm /mach_kernel|wc -l
   16122
</code></pre>

<p>Surely all the symbols in all the KPI symbol tables add up to the same number, right?</p>

<pre><code>$ find /System/Library/Extensions/System.kext/PlugIns -type f|grep -v plist|xargs nm|sort|uniq|wc -l
    7677
</code></pre>

<p>Nope. Apple doesn’t want us to play with a whole bunch of their toys. 8445 of them. Some of them are pretty fun too :( Like <code>allproc</code>:</p>

<pre><code>$ nm /mach_kernel|grep allproc
ffffff80008d9e40 S _allproc
$ find /System/Library/Extensions/System.kext/PlugIns -type f|grep -v plist|xargs nm|sort|uniq|grep allproc
$ 
</code></pre>

<p>Damn. The <code>allproc</code> symbol is the head of the kernel’s list (the <code>queue(3)</code> kind of list) of running processes. It’s what gets queried when you run <code>ps(1)</code> or <code>top(1)</code>. Why do we want to find <code>allproc</code>? If we want to hide processes in a kernel rootkit that’s the best place to start. So, what happens if we build a kernel extension that imports <code>allproc</code> and try to load it?</p>

<pre><code>bash-3.2# kextload AllProcRocks.kext
/Users/admin/AllProcRocks.kext failed to load - (libkern/kext) link error; check the system/kernel logs for errors or try kextutil(8).
</code></pre>

<p>Console says:</p>

<pre><code>25/02/12 6:30:47.000 PM kernel: kxld[ax.ho.kext.AllProcRocks]: The following symbols are unresolved for this kext:
25/02/12 6:30:47.000 PM kernel: kxld[ax.ho.kext.AllProcRocks]: 	_allproc
</code></pre>

<p>OK, whatever.</p>

<h2 id="what-do-we-do">What do we do?</h2>

<p>There are a few steps that we need to take in order to resolve symbols in the kernel (or any other Mach-O binary):</p>

<ul>
  <li>Find the <code>__LINKEDIT</code> segment - this contains an array of <code>struct nlist_64</code>’s which represent all the symbols in the symbol table, and an array of symbol name strings.</li>
  <li>Find the <code>LC_SYMTAB</code> load command - this contains the offsets within the file of the symbol and string tables.</li>
  <li>Calculate the position of the string table within <code>__LINKEDIT</code> based on the offsets in the <code>LC_SYMTAB</code> load command.</li>
  <li>Iterate through the <code>struct nlist_64</code>’s in <code>__LINKEDIT</code>, comparing the corresponding string in the string table to the name of the symbol we’re looking for until we find it (or reach the end of the symbol table).</li>
  <li>Grab the address of the symbol from the <code>struct nlist_64</code> we’ve found.</li>
</ul>

<h2 id="parse-the-load-commands">Parse the load commands</h2>

<p>One easy way to look at the symbol table would be to read the kernel file on disk at <code>/mach_kernel</code>, but we can do better than that if we’re already in the kernel - the kernel image is loaded into memory at a known address. If we have a look at the load commands for the kernel binary:</p>

<pre><code>$ otool -l /mach_kernel
/mach_kernel:
Load command 0
      cmd LC_SEGMENT_64
  cmdsize 472
  segname __TEXT
   vmaddr 0xffffff8000200000
   vmsize 0x000000000052f000
  fileoff 0
 filesize 5435392
  maxprot 0x00000007
 initprot 0x00000005
   nsects 5
    flags 0x0
&lt;snip&gt;
</code></pre>

<p>We can see that the <code>vmaddr</code> field of the first segment is <code>0xffffff8000200000</code>. If we fire up GDB and point it at a VM running Mac OS X (as per my previous posts <a href="/posts/2012/02/debugging-the-mac-os-x-kernel-with-vmware-and-gdb/">here</a> and <a href="/posts/2012/02/vmware-hardware-debugging/">here</a>), we can see the start of the Mach-O header in memory at this address:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">x</span>/<span class="kc">xw</span> <span class="mh">0xffffff8000200000</span>
<span class="mh">0xffffff8000200000</span>:	<span class="mh">0xfeedfacf</span></code></pre>

<p><code>0xfeedfacf</code> is the magic number denoting a 64-bit Mach-O image (the 32-bit version is <code>0xfeedface</code>). We can actually display this as a struct if we’re using the DEBUG kernel with all the DWARF info:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct mach_header_64 *</span>)<span class="mh">0xffffff8000200000</span>
<span class="nv">$1</span> = {
  <span class="nv">magic</span> = <span class="mh">0xfeedfacf</span>, 
  <span class="nv">cputype</span> = <span class="mh">0x1000007</span>, 
  <span class="nv">cpusubtype</span> = <span class="mh">0x3</span>, 
  <span class="nv">filetype</span> = <span class="mh">0x2</span>, 
  <span class="nv">ncmds</span> = <span class="mh">0x12</span>, 
  <span class="nv">sizeofcmds</span> = <span class="mh">0x1010</span>, 
  <span class="nv">flags</span> = <span class="mh">0x1</span>, 
  <span class="nv">reserved</span> = <span class="mh">0x0</span>
}</code></pre>

<p>The <code>mach_header</code> and <code>mach_header_64</code> structs (along with the other Mach-O-related structs mentioned in this post) are documented in the <a href="https://developer.apple.com/library/mac/#documentation/developertools/conceptual/MachORuntime/Reference/reference.html">Mach-O File Format Reference</a>, but we aren’t particularly interested in the header at the moment. I recommend having a look at the kernel image with <a href="http://sourceforge.net/projects/machoview/">MachOView</a> to get the gist of where everything is and how it’s laid out.</p>

<p>Directly following the Mach-O header is the first load command:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$mh</span><span class="o">=</span>(<span class="kt">struct mach_header_64 *</span>)<span class="mh">0xffffff8000200000</span>
<span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct load_command*</span>)((void *)<span class="nv">$mh</span> + sizeof(struct mach_header_<span class="mh">64</span>))
<span class="nv">$6</span> = {
  <span class="nv">cmd</span> = <span class="mh">0x19</span>, 
  <span class="nv">cmdsize</span> = <span class="mh">0x1d8</span>
}</code></pre>

<p>This is the load command for the first <code>__TEXT</code> segment we saw with <code>otool</code>. We can cast it as a <code>segment_command_64</code> in GDB and have a look:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$lc</span><span class="o">=</span>((void *)<span class="nv">$mh</span> + sizeof(struct mach_header_<span class="mh">64</span>))
<span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct segment_command_64 *</span>)<span class="nv">$lc</span>
<span class="nv">$7</span> = {
  <span class="nv">cmd</span> = <span class="mh">0x19</span>, 
  <span class="nv">cmdsize</span> = <span class="mh">0x1d8</span>, 
  <span class="nv">segname</span> = <span class="s">"__TEXT\000\000\000\000\000\000\000\000\000"</span>, 
  <span class="nv">vmaddr</span> = <span class="mh">0xffffff8000200000</span>, 
  <span class="nv">vmsize</span> = <span class="mh">0x8c8000</span>, 
  <span class="nv">fileoff</span> = <span class="mh">0x0</span>, 
  <span class="nv">filesize</span> = <span class="mh">0x8c8000</span>, 
  <span class="nv">maxprot</span> = <span class="mh">0x7</span>, 
  <span class="nv">initprot</span> = <span class="mh">0x5</span>, 
  <span class="nv">nsects</span> = <span class="mh">0x5</span>, 
  <span class="nv">flags</span> = <span class="mh">0x0</span>
}</code></pre>

<p>This isn’t the load command we are looking for, so we have to iterate through all of them until we come across a segment with <code>cmd</code> of <code>0x19</code> (<code>LC_SEGMENT_64</code>) and <code>segname</code> of <code>__LINKEDIT</code>. In the debug kernel, this happens to be located at <code>0xffffff8000200e68</code>:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$lc</span><span class="o">=</span><span class="mh">0xffffff8000200e68</span>
<span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct load_command*</span>)<span class="nv">$lc</span>   
<span class="nv">$14</span> = {
  <span class="nv">cmd</span> = <span class="mh">0x19</span>, 
  <span class="nv">cmdsize</span> = <span class="mh">0x48</span>
}
<span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct segment_command_64*</span>)<span class="nv">$lc</span>
<span class="nv">$16</span> = {
  <span class="nv">cmd</span> = <span class="mh">0x19</span>, 
  <span class="nv">cmdsize</span> = <span class="mh">0x48</span>, 
  <span class="nv">segname</span> = <span class="s">"__LINKEDIT\000\000\000\000\000"</span>, 
  <span class="nv">vmaddr</span> = <span class="mh">0xffffff8000d08000</span>, 
  <span class="nv">vmsize</span> = <span class="mh">0x109468</span>, 
  <span class="nv">fileoff</span> = <span class="mh">0xaf4698</span>, 
  <span class="nv">filesize</span> = <span class="mh">0x109468</span>, 
  <span class="nv">maxprot</span> = <span class="mh">0x7</span>, 
  <span class="nv">initprot</span> = <span class="mh">0x1</span>, 
  <span class="nv">nsects</span> = <span class="mh">0x0</span>, 
  <span class="nv">flags</span> = <span class="mh">0x0</span>
}</code></pre>

<p>Then we grab the <code>vmaddr</code> field from the load command, which specifies the address at which the <code>__LINKEDIT</code> segment’s data will be located:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$linkedit</span><span class="o">=</span>((<span class="kt">struct segment_command_64*</span>)<span class="nv">$lc</span>)<span class="na">-&gt;vmaddr</span>
<span class="kt">gdb$</span> <span class="nb">print</span> <span class="nv">$linkedit</span>
$<span class="mh">19</span> <span class="o">=</span> <span class="mh">0xffffff8000d08000</span>
<span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct nlist_64 *</span>)<span class="nv">$linkedit</span>
<span class="nv">$20</span> = {
  <span class="nv">n_un</span> = {
    <span class="nv">n_strx</span> = <span class="mh">0x68a29</span>
  }, 
  <span class="nv">n_type</span> = <span class="mh">0xe</span>, 
  <span class="nv">n_sect</span> = <span class="mh">0x1</span>, 
  <span class="nv">n_desc</span> = <span class="mh">0x0</span>, 
  <span class="nv">n_value</span> = <span class="mh">0xffffff800020a870</span>
}</code></pre>

<p>And there’s the first <code>struct nlist_64</code>.</p>

<p>As for the <code>LC_SYMTAB</code> load command, we just need to iterate through the load commands until we find one with the <code>cmd</code> field value of <code>0x02</code> (<code>LC_SYMTAB</code>). In this case, it’s located at <code>0xffffff8000200eb0</code>:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$symtab</span><span class="o">=</span>*(<span class="kt">struct symtab_command*</span>)<span class="mh">0xffffff8000200eb0</span>
<span class="kt">gdb$</span> <span class="nb">print</span> <span class="nv">$symtab</span>
<span class="nv">$23</span> = {
  <span class="nv">cmd</span> = <span class="mh">0x2</span>, 
  <span class="nv">cmdsize</span> = <span class="mh">0x18</span>, 
  <span class="nv">symoff</span> = <span class="mh">0xaf4698</span>, 
  <span class="nv">nsyms</span> = <span class="mh">0x699d</span>, 
  <span class="nv">stroff</span> = <span class="mh">0xb5e068</span>, 
  <span class="nv">strsize</span> = <span class="mh">0x9fa98</span>
}</code></pre>

<p>The useful parts here are the <code>symoff</code> field, which specifies the offset in the file to the symbol table (start of the <code>__LINKEDIT</code> segment), and the <code>stroff</code> field, which specifies the offset in the file to the string table (somewhere in the middle of the <code>__LINKEDIT</code> segment). Why, you ask, did we need to find the <code>__LINKEDIT</code> segment as well, since we have the offset here in the <code>LC_SYMTAB</code> command? If we were looking at the file on disk we wouldn’t have needed to, but as the kernel image we’re inspecting has already been loaded into memory, the binary segments have been loaded at the virtual memory addresses specified in their load commands. This means that the <code>symoff</code> and <code>stroff</code> fields are not correct any more. However, they’re still useful, as the difference between the two helps us figure out the offset into the <code>__LINKEDIT</code> segment at which the string table exists:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">print</span> <span class="nv">$linkedit</span>
$<span class="mh">24</span> <span class="o">=</span> <span class="mh">0xffffff8000d08000</span>
<span class="kt">gdb$</span> <span class="nb">print</span> <span class="nv">$linkedit</span> + (<span class="nv">$symtab</span><span class="na">-&gt;stroff</span> - <span class="nv">$symtab</span><span class="na">-&gt;symoff</span>)
$<span class="mh">25</span> <span class="o">=</span> <span class="mh">0xffffff8000d719d0</span>
<span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$strtab</span><span class="o">=</span><span class="nv">$linkedit</span> + (<span class="nv">$symtab</span><span class="na">-&gt;stroff</span> - <span class="nv">$symtab</span><span class="na">-&gt;symoff</span>)
<span class="kt">gdb$</span> <span class="nb">x</span>/<span class="mi">16</span><span class="kc">s</span> <span class="nv">$strtab</span>
<span class="mh">0xffffff8000d719d0</span>:	 <span class="s">""</span>
<span class="mh">0xffffff8000d719d1</span>:	 <span class="s">""</span>
<span class="mh">0xffffff8000d719d2</span>:	 <span class="s">""</span>
<span class="mh">0xffffff8000d719d3</span>:	 <span class="s">""</span>
<span class="mh">0xffffff8000d719d4</span>:	 <span class="s">".constructors_used"</span>
<span class="mh">0xffffff8000d719e7</span>:	 <span class="s">".destructors_used"</span>
<span class="mh">0xffffff8000d719f9</span>:	 <span class="s">"_AddFileExtent"</span>
<span class="mh">0xffffff8000d71a08</span>:	 <span class="s">"_AllocateNode"</span>
<span class="mh">0xffffff8000d71a16</span>:	 <span class="s">"_Assert"</span>
<span class="mh">0xffffff8000d71a1e</span>:	 <span class="s">"_BF_decrypt"</span>
<span class="mh">0xffffff8000d71a2a</span>:	 <span class="s">"_BF_encrypt"</span>
<span class="mh">0xffffff8000d71a36</span>:	 <span class="s">"_BF_set_key"</span>
<span class="mh">0xffffff8000d71a42</span>:	 <span class="s">"_BTClosePath"</span>
<span class="mh">0xffffff8000d71a4f</span>:	 <span class="s">"_BTDeleteRecord"</span>
<span class="mh">0xffffff8000d71a5f</span>:	 <span class="s">"_BTFlushPath"</span>
<span class="mh">0xffffff8000d71a6c</span>:	 <span class="s">"_BTGetInformation"</span></code></pre>

<h2 id="actually-finding-some-symbols">Actually finding some symbols</h2>

<p>Now that we know where the symbol table and string table live, we can get on to the srs bznz. So, let’s find that damn <code>_allproc</code> symbol we need. Have a look at that first <code>struct nlist_64</code> again:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct nlist_64 *</span>)<span class="nv">$linkedit</span>
<span class="nv">$28</span> = {
  <span class="nv">n_un</span> = {
    <span class="nv">n_strx</span> = <span class="mh">0x68a29</span>
  }, 
  <span class="nv">n_type</span> = <span class="mh">0xe</span>, 
  <span class="nv">n_sect</span> = <span class="mh">0x1</span>, 
  <span class="nv">n_desc</span> = <span class="mh">0x0</span>, 
  <span class="nv">n_value</span> = <span class="mh">0xffffff800020a870</span>
}</code></pre>

<p>The <code>n_un.nstrx</code> field there specifies the offset into the string table at which the string corresponding to this symbol exists. If we add that offset to the address at which the string table starts, we’ll see the symbol name:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">x</span>/<span class="kc">s</span> <span class="nv">$strtab</span> + ((<span class="kt">struct nlist_64 *</span>)<span class="nv">$linkedit</span>)<span class="na">-&gt;n_un.n_strx</span>
<span class="mh">0xffffff8000dda3f9</span>:	 <span class="s">"_ps_vnode_trim_init"</span></code></pre>

<p>Now all we need to do is iterate through all the <code>struct nlist_64</code>’s until we find the one with the matching name. In this case it’s at <code>0xffffff8000d482a0</code>:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$nlist</span><span class="o">=</span><span class="mh">0xffffff8000d482a0</span>
<span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct nlist_64*</span>)<span class="nv">$nlist</span>
<span class="nv">$31</span> = {
  <span class="nv">n_un</span> = {
    <span class="nv">n_strx</span> = <span class="mh">0x35a07</span>
  }, 
  <span class="nv">n_type</span> = <span class="mh">0xf</span>, 
  <span class="nv">n_sect</span> = <span class="mh">0xb</span>, 
  <span class="nv">n_desc</span> = <span class="mh">0x0</span>, 
  <span class="nv">n_value</span> = <span class="mh">0xffffff8000cb5ca0</span>
}
<span class="kt">gdb$</span> <span class="nb">x</span>/<span class="kc">s</span> <span class="nv">$strtab</span> + ((<span class="kt">struct nlist_64 *</span>)<span class="nv">$nlist</span>)<span class="na">-&gt;n_un.n_strx</span>
<span class="mh">0xffffff8000da73d7</span>:	 <span class="s">"_allproc"</span></code></pre>

<p>The <code>n_value</code> field there (<code>0xffffff8000cb5ca0</code>) is the virtual memory address at which the symbol’s data/code exists. <code>_allproc</code> is not a great example as it’s a piece of data, rather than a function, so let’s try it with a function:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">set</span> <span class="nv">$nlist</span><span class="o">=</span><span class="mh">0xffffff8000d618f0</span>
<span class="kt">gdb$</span> <span class="nb">print</span> *(<span class="kt">struct nlist_64*</span>)<span class="nv">$nlist</span>
<span class="nv">$32</span> = {
  <span class="nv">n_un</span> = {
    <span class="nv">n_strx</span> = <span class="mh">0x52ed3</span>
  }, 
  <span class="nv">n_type</span> = <span class="mh">0xf</span>, 
  <span class="nv">n_sect</span> = <span class="mh">0x1</span>, 
  <span class="nv">n_desc</span> = <span class="mh">0x0</span>, 
  <span class="nv">n_value</span> = <span class="mh">0xffffff80007cceb0</span>
}
<span class="kt">gdb$</span> <span class="nb">x</span>/<span class="kc">s</span> <span class="nv">$strtab</span> + ((<span class="kt">struct nlist_64 *</span>)<span class="nv">$nlist</span>)<span class="na">-&gt;n_un.n_strx</span>
<span class="mh">0xffffff8000dc48a3</span>:	 <span class="s">"_proc_lock"</span></code></pre>

<p>If we disassemble a few instructions at that address:</p>

<pre><code class="language-gdb"><span class="kt">gdb$</span> <span class="nb">x</span>/<span class="mi">12</span><span class="kc">i</span> <span class="mh">0xffffff80007cceb0</span>
<span class="mh">0xffffff80007cceb0</span> <span class="nf">&lt;proc_lock&gt;</span>:	push   rbp
<span class="mh">0xffffff80007cceb1</span> <span class="nf">&lt;proc_lock+1&gt;</span>:	mov    rbp,rsp
<span class="mh">0xffffff80007cceb4</span> <span class="nf">&lt;proc_lock+4&gt;</span>:	sub    rsp,<span class="mh">0x10</span>
<span class="mh">0xffffff80007cceb8</span> <span class="nf">&lt;proc_lock+8&gt;</span>:	mov    QWORD PTR [rbp-<span class="mh">0x8</span>],rdi
<span class="mh">0xffffff80007ccebc</span> <span class="nf">&lt;proc_lock+12&gt;</span>:	mov    rax,QWORD PTR [rbp-<span class="mh">0x8</span>]
<span class="mh">0xffffff80007ccec0</span> <span class="nf">&lt;proc_lock+16&gt;</span>:	mov    rcx,<span class="mh">0x50</span>
<span class="mh">0xffffff80007cceca</span> <span class="nf">&lt;proc_lock+26&gt;</span>:	add    rax,rcx
<span class="mh">0xffffff80007ccecd</span> <span class="nf">&lt;proc_lock+29&gt;</span>:	mov    rdi,rax
<span class="mh">0xffffff80007cced0</span> <span class="nf">&lt;proc_lock+32&gt;</span>:	call   <span class="mh">0xffffff800035d270</span> <span class="nf">&lt;lck_mtx_lock&gt;</span>
<span class="mh">0xffffff80007cced5</span> <span class="nf">&lt;proc_lock+37&gt;</span>:	add    rsp,<span class="mh">0x10</span>
<span class="mh">0xffffff80007cced9</span> <span class="nf">&lt;proc_lock+41&gt;</span>:	pop    rbp
<span class="mh">0xffffff80007cceda</span> <span class="nf">&lt;proc_lock+42&gt;</span>:	ret</code></pre>

<p>We can see that GDB has resolved the symbol for us, and we’re right on the money.</p>

<h2 id="sample-code">Sample code</h2>

<p>I’ve posted an example kernel extension on <a href="https://github.com/snarez/KernelResolver">github</a> to check out. When we load it with <code>kextload KernelResolver.kext</code>, we should see something like this on the console:</p>

<pre><code>25/02/12 8:06:49.000 PM kernel: [+] _allproc @ 0xffffff8000cb5ca0
25/02/12 8:06:49.000 PM kernel: [+] _proc_lock @ 0xffffff80007cceb0
25/02/12 8:06:49.000 PM kernel: [+] _kauth_cred_setuidgid @ 0xffffff80007abbb0
25/02/12 8:06:49.000 PM kernel: [+] __ZN6OSKext13loadFromMkextEjPcjPS0_Pj @ 0xffffff80008f8606
</code></pre>

<p><strong>Update</strong>: It was brought to my attention that I was using a debug kernel in these examples. Just to be clear - the method described in this post, as well as the sample code, works on a non-debug, default install &gt;=10.7.0 (xnu-1699.22.73) kernel as well, but the GDB inspection probably won’t (unless you load up the struct definitions etc, as they are all stored in the DEBUG kernel). The debug kernel contains every symbol from the source, whereas many symbols are stripped from the distribution kernel (e.g. <code>sLoadedKexts</code>). Previously (before 10.7), the kernel would write out the symbol table to a file on disk and jettison it from memory altogether. I suppose when kernel extensions were loaded, <code>kextd</code> or <code>kextload</code> would resolve symbols from within that on-disk symbol table or from the on-disk kernel image. These days the symbol table memory is just marked as pageable, so it can potentially get paged out if the system is short of memory.</p>

<p>I hope somebody finds this useful. Shoot me an email or get at me on twitter if you have any questions. I’ll probably sort out comments for this blog at some point, but I cbf at the moment.</p>


  
	<hr/>
  

              </div>
            </div>
            <div class="grid_3">
              <div id="sidebar">
                <h2>PAGES</h2>
                <ul>
                  <li><a href="/">Home</a></li>
                  <li><a href="/about">About</a></li>
                  <li><a href="/downloads">Downloads</a></li>
                </ul>
                <h2>TAGS</h2>
                <p><a class="tagcloud" style="font-size:78.23529411764706%;" href="/tag/voltron/" rel="tag">voltron</a> <a class="tagcloud" style="font-size:85.29411764705883%;" href="/tag/debugging/" rel="tag">debugging</a> <a class="tagcloud" style="font-size:85.29411764705883%;" href="/tag/gdb/" rel="tag">gdb</a> <a class="tagcloud" style="font-size:64.11764705882352%;" href="/tag/lldb/" rel="tag">lldb</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/calculon/" rel="tag">calculon</a> <a class="tagcloud" style="font-size:120.58823529411765%;" href="/tag/efi/" rel="tag">efi</a> <a class="tagcloud" style="font-size:71.17647058823529%;" href="/tag/ida pro/" rel="tag">ida pro</a> <a class="tagcloud" style="font-size:64.11764705882352%;" href="/tag/idapython/" rel="tag">idapython</a> <a class="tagcloud" style="font-size:64.11764705882352%;" href="/tag/reversing/" rel="tag">reversing</a> <a class="tagcloud" style="font-size:85.29411764705883%;" href="/tag/rootkits/" rel="tag">rootkits</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/refind/" rel="tag">refind</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/black hat/" rel="tag">black hat</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/firmware/" rel="tag">firmware</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/bus pirate/" rel="tag">bus pirate</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/flashrom/" rel="tag">flashrom</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/pci/" rel="tag">pci</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/syscan/" rel="tag">syscan</a> <a class="tagcloud" style="font-size:78.23529411764706%;" href="/tag/mac os x/" rel="tag">mac os x</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/x86-64/" rel="tag">x86-64</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/clang/" rel="tag">clang</a> <a class="tagcloud" style="font-size:71.17647058823529%;" href="/tag/kernel/" rel="tag">kernel</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/kexts/" rel="tag">kexts</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/mach-o/" rel="tag">mach-o</a> <a class="tagcloud" style="font-size:57.05882352941176%;" href="/tag/python/" rel="tag">python</a> <a class="tagcloud" style="font-size:64.11764705882352%;" href="/tag/vmware/" rel="tag">vmware</a> </p>
                <h2>POSTS</h2>
                <ul>
                  
                    <li><a href="/posts/2015/05/building-voltron-command-plugins/">Building Voltron Command Plugins</a></li>
                  
                    <li><a href="/posts/2014/12/building-voltron-views/">Building Voltron Views</a></li>
                  
                    <li><a href="/posts/2013/10/calculon-a-calculator-for-nerds/">Calculon - a calculator for nerds</a></li>
                  
                    <li><a href="/posts/2013/06/voltron-a-hacky-ui-for-gdb/">Voltron - a hacky UI for GDB</a></li>
                  
                    <li><a href="/posts/2012/12/te-loader-for-ida-pro/">TE loader for IDA Pro</a></li>
                  
                    <li><a href="/posts/2012/10/ruxcon/">Ruxcon 2012</a></li>
                  
                    <li><a href="/posts/2012/09/ida-pro-scripts-for-efi-reversing/">IDA Pro scripts for EFI reversing</a></li>
                  
                    <li><a href="/posts/2012/08/building-refind-with-edk2-on-osx/">Building rEFInd with EDKII on Mac OS X</a></li>
                  
                    <li><a href="/posts/2012/07/black-hat-usa-2012/">Black Hat USA 2012</a></li>
                  
                    <li><a href="/posts/2012/06/unbricking-a-macbook/">Un-bricking a MacBook</a></li>
                  
                    <li><a href="/posts/2012/06/send-me-your-lspci/">Send me your `lspci -vv`</a></li>
                  
                    <li><a href="/posts/2012/05/syscan-2012-is-over/">SyScan 2012 is Over</a></li>
                  
                    <li><a href="/posts/2012/03/rip-relative-addressing-and-kernel-payloads/">RIP-Relative Addressing and Kernel Payloads</a></li>
                  
                    <li><a href="/posts/2012/02/resolving-kernel-symbols/">Resolving kernel symbols</a></li>
                  
                    <li><a href="/posts/2012/02/carving-up-efi-fat-binaries/">Carving up EFI fat binaries</a></li>
                  
                    <li><a href="/posts/2012/02/vmware-hardware-debugging/">VMware debugging II&#58; "Hardware" debugging</a></li>
                  
                    <li><a href="/posts/2012/02/debugging-the-mac-os-x-kernel-with-vmware-and-gdb/">Debugging the Mac OS X kernel with VMware and GDB</a></li>
                  
                </ul>
                <h2>SEARCH</h2>
                <form method="get" action="http://www.google.com/search">
                  <fieldset>
                    <input type="hidden" name="sitesearch" value="ho.ax"/>
                    <input type="text" class="searchbox" name="q" size="31" maxlength="255" value=""/>
                    <input type="image" class="searchbutton" width=24 height=24 src="/img/search.png" value="Search"/>
                  </fieldset>
                </form>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="splitbar">&nbsp;</div>
      <div id="footer">
          <div class="container_12">
            <div class="grid_9">
              <p>Last updated on 9 May 2015 by . Please don't steal my stuff.</p>
            </div>
            <div class="grid_3">
              <div class="media">
                <div style="float: left"><a class="twitter" href="http://twitter.com/snare"></a></div>
                <div style="float: left"><a class="rss" href="/feed.xml"></a></div>
              </div>
            </div>
        </div>
      </div>
    </div>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29183428-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script>
  <img src="/img/twitter_active.png" style="display: none" />
  <img src="/img/rss_active.png" style="display: none" />
  </body>
</html>
